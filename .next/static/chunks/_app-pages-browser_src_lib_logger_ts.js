"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_src_lib_logger_ts"],{

/***/ "(app-pages-browser)/./src/lib/logger.ts":
/*!***************************!*\
  !*** ./src/lib/logger.ts ***!
  \***************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Logger: () => (/* binding */ Logger),\n/* harmony export */   apiLogger: () => (/* binding */ apiLogger),\n/* harmony export */   authLogger: () => (/* binding */ authLogger),\n/* harmony export */   dbLogger: () => (/* binding */ dbLogger),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   logger: () => (/* binding */ logger),\n/* harmony export */   securityLogger: () => (/* binding */ securityLogger)\n/* harmony export */ });\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n/**\n * Enhanced logger for production and development environments\n * Provides structured logging with different levels and environments\n */ class Logger {\n    static getInstance() {\n        let context = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 'Application';\n        if (!Logger.instance) {\n            Logger.instance = new Logger(context);\n        }\n        return Logger.instance;\n    }\n    getLogLevel() {\n        var _process_env_LOG_LEVEL;\n        const envLevel = (_process_env_LOG_LEVEL = process.env.LOG_LEVEL) === null || _process_env_LOG_LEVEL === void 0 ? void 0 : _process_env_LOG_LEVEL.toLowerCase();\n        const validLevels = [\n            'debug',\n            'info',\n            'warn',\n            'error'\n        ];\n        if (validLevels.includes(envLevel)) {\n            return envLevel;\n        }\n        // Default to info in production, debug in development\n        return  false ? 0 : 'debug';\n    }\n    shouldLog(level) {\n        const levels = [\n            'debug',\n            'info',\n            'warn',\n            'error'\n        ];\n        const currentLevelIndex = levels.indexOf(this.logLevel);\n        const messageLevelIndex = levels.indexOf(level);\n        return messageLevelIndex >= currentLevelIndex;\n    }\n    formatMessage(level, message, data, error) {\n        return {\n            message,\n            level,\n            timestamp: new Date().toISOString(),\n            context: this.context,\n            data,\n            error\n        };\n    }\n    logToConsole(logData) {\n        const { level, message, timestamp, context, data, error } = logData;\n        const logMessage = \"[\".concat(timestamp, \"] [\").concat(level.toUpperCase(), \"] [\").concat(context, \"] \").concat(message);\n        switch(level){\n            case 'debug':\n                if (true) {\n                    console.debug(logMessage, data || '');\n                }\n                break;\n            case 'info':\n                break;\n            case 'warn':\n                break;\n            case 'error':\n                console.error(logMessage, error || data || '');\n                break;\n        }\n    }\n    debug(message, data) {\n        if (this.shouldLog('debug')) {\n            const logData = this.formatMessage('debug', message, data);\n            this.logToConsole(logData);\n        }\n    }\n    info(message, data) {\n        if (this.shouldLog('info')) {\n            const logData = this.formatMessage('info', message, data);\n            this.logToConsole(logData);\n        }\n    }\n    warn(message, data) {\n        if (this.shouldLog('warn')) {\n            const logData = this.formatMessage('warn', message, data);\n            this.logToConsole(logData);\n        }\n    }\n    error(message, error, data) {\n        if (this.shouldLog('error')) {\n            const logData = this.formatMessage('error', message, data, error instanceof Error ? error : undefined);\n            this.logToConsole(logData);\n            // In production, you might want to send errors to external service\n            if (false) {}\n        }\n    }\n    sendToExternalService(logData) {\n        try {\n            // Sentry integration\n            if (process.env.SENTRY_DSN && logData.level === 'error') {\n                this.sendToSentry(logData);\n            }\n            // CloudWatch Logs integration\n            if (process.env.AWS_CLOUDWATCH_LOG_GROUP) {\n                this.sendToCloudWatch(logData);\n            }\n            // Generic webhook integration\n            if (process.env.ERROR_WEBHOOK_URL && logData.level === 'error') {\n                this.sendToWebhook(logData);\n            }\n        } catch (externalError) {\n            // Don't let external service errors break the application\n            console.error('Failed to send log to external service:', externalError);\n        }\n    }\n    sendToSentry(logData) {\n        // Dynamic import to avoid bundle bloat if Sentry isn't used\n        try {\n            // Check if Sentry is available before importing\n            if ( true && window.Sentry) {\n                // Client-side Sentry is available\n                const Sentry = window.Sentry;\n                this.sendToSentryInstance(Sentry, logData);\n            } else {\n                // Try dynamic import for server-side\n                __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_sentry_nextjs_build_esm_index_client_js\").then(__webpack_require__.bind(__webpack_require__, /*! @sentry/nextjs */ \"(app-pages-browser)/./node_modules/@sentry/nextjs/build/esm/index.client.js\")).then((Sentry)=>{\n                    this.sendToSentryInstance(Sentry.default || Sentry, logData);\n                }).catch(()=>{\n                // Sentry not available, silently ignore\n                });\n            }\n        } catch (e) {\n        // Sentry not available, silently ignore\n        }\n    }\n    sendToSentryInstance(Sentry, logData) {\n        if (logData.error) {\n            Sentry.captureException(logData.error, {\n                tags: {\n                    context: logData.context,\n                    level: logData.level\n                },\n                extra: {\n                    message: logData.message,\n                    data: logData.data,\n                    userId: logData.userId,\n                    sessionId: logData.sessionId,\n                    requestId: logData.requestId\n                }\n            });\n        } else {\n            Sentry.captureMessage(logData.message, {\n                level: logData.level === 'error' ? 'error' : 'warning',\n                tags: {\n                    context: logData.context\n                },\n                extra: {\n                    data: logData.data,\n                    userId: logData.userId,\n                    sessionId: logData.sessionId,\n                    requestId: logData.requestId\n                }\n            });\n        }\n    }\n    sendToCloudWatch(logData) {\n        // AWS CloudWatch integration would go here\n        // This is a placeholder for actual implementation\n        if (false) {}\n    }\n    async sendToWebhook(logData) {\n        try {\n            await fetch(process.env.ERROR_WEBHOOK_URL, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json'\n                },\n                body: JSON.stringify({\n                    ...logData,\n                    service: 'manitos-pintadas',\n                    environment: \"development\"\n                })\n            });\n        } catch (error) {\n            console.error('Failed to send error to webhook:', error);\n        }\n    }\n    // Enhanced error tracking methods\n    logApiError(endpoint, error, context, userId, sessionId) {\n        this.error(\"API Error: \".concat(endpoint), error, {\n            context,\n            userId,\n            sessionId,\n            endpoint,\n            userAgent:  true ? window.navigator.userAgent : 0,\n            url:  true ? window.location.href : 0\n        });\n    }\n    logDatabaseError(operation, error, context) {\n        this.error(\"Database Error: \".concat(operation), error, {\n            context,\n            operation,\n            database: process.env.DATABASE_URL ? 'configured' : 'not-configured'\n        });\n    }\n    logSecurityEvent(event, userId, details) {\n        let severity = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 'medium';\n        const level = severity === 'critical' ? 'error' : 'warn';\n        const logData = this.formatMessage(level, \"Security Event: \".concat(event), {\n            userId,\n            details,\n            severity,\n            ip: details === null || details === void 0 ? void 0 : details.ip,\n            userAgent: details === null || details === void 0 ? void 0 : details.userAgent\n        });\n        if (level === 'error') {\n            this.error(\"Security Event: \".concat(event), undefined, {\n                userId,\n                details,\n                severity\n            });\n        } else {\n            this.warn(\"Security Event: \".concat(event), {\n                userId,\n                details,\n                severity\n            });\n        }\n    }\n    logUserAction(action, userId, details) {\n        this.info(\"User Action: \".concat(action), {\n            userId,\n            details,\n            timestamp: new Date().toISOString()\n        });\n    }\n    logPerformanceMetric(metric, value, context) {\n        this.info(\"Performance: \".concat(metric), {\n            value,\n            context,\n            timestamp: new Date().toISOString()\n        });\n    }\n    // Error boundary specific logging\n    logErrorBoundary(error, errorInfo, componentName) {\n        this.error('Error Boundary Caught Error', error, {\n            componentName,\n            componentStack: errorInfo.componentStack,\n            errorBoundary: true,\n            timestamp: new Date().toISOString()\n        });\n    }\n    // Client-side error tracking\n    logClientError(error, context) {\n        this.error('Client Error', error, {\n            context,\n            userAgent:  true ? window.navigator.userAgent : 0,\n            url:  true ? window.location.href : 0,\n            timestamp: new Date().toISOString(),\n            clientSide: true\n        });\n    }\n    constructor(context = 'Application'){\n        this.context = context;\n        this.logLevel = this.getLogLevel();\n    }\n}\n// Convenience exports\nconst logger = Logger.getInstance('Application');\n// Context-specific loggers\nconst authLogger = Logger.getInstance('Auth');\nconst apiLogger = Logger.getInstance('API');\nconst dbLogger = Logger.getInstance('Database');\nconst securityLogger = Logger.getInstance('Security');\n// Export for backward compatibility\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (logger);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFHMUIsT0FBTzJCLFFBQVEsQ0FBQ0MsSUFBSSxHQUFHckMsQ0FBU0E7WUFDckVaLFdBQVcsSUFBSUMsT0FBT0MsV0FBVztZQUNqQ29FLFlBQVk7UUFDZDtJQUNGO0lBelJBLFlBQVkzRixVQUFrQixhQUFhLENBQUU7UUFDM0MsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDZSxRQUFRLEdBQUcsSUFBSSxDQUFDYixXQUFXO0lBQ2xDO0FBdVJGO0FBRUEsc0JBQXNCO0FBQ2YsTUFBTTBGLFNBQVM5RixPQUFPQyxXQUFXLENBQUMsZUFBZTtBQUV4RCwyQkFBMkI7QUFDcEIsTUFBTThGLGFBQWEvRixPQUFPQyxXQUFXLENBQUMsUUFBUTtBQUM5QyxNQUFNK0YsWUFBWWhHLE9BQU9DLFdBQVcsQ0FBQyxPQUFPO0FBQzVDLE1BQU1nRyxXQUFXakcsT0FBT0MsV0FBVyxDQUFDLFlBQVk7QUFDaEQsTUFBTWlHLGlCQUFpQmxHLE9BQU9DLFdBQVcsQ0FBQyxZQUFZO0FBRTdELG9DQUFvQztBQUNwQyxpRUFBZTZGLE1BQU1BLEVBQUMiLCJzb3VyY2VzIjpbIi9tbnQvU2Vjb25kYXJ5L1Byb2plY3RzL1dlYnNpdGVzL1NjaG9vbHMvTWFuaXRvcyBQaW50YWRhcyBTUUwvc3JjL2xpYi9sb2dnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBFbmhhbmNlZCBsb2dnZXIgZm9yIHByb2R1Y3Rpb24gYW5kIGRldmVsb3BtZW50IGVudmlyb25tZW50c1xuICogUHJvdmlkZXMgc3RydWN0dXJlZCBsb2dnaW5nIHdpdGggZGlmZmVyZW50IGxldmVscyBhbmQgZW52aXJvbm1lbnRzXG4gKi9cblxuZXhwb3J0IHR5cGUgTG9nTGV2ZWwgPSAnZGVidWcnIHwgJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJztcblxuZXhwb3J0IGludGVyZmFjZSBMb2dEYXRhIHtcbiAgbWVzc2FnZTogc3RyaW5nO1xuICBsZXZlbDogTG9nTGV2ZWw7XG4gIHRpbWVzdGFtcDogc3RyaW5nO1xuICBjb250ZXh0Pzogc3RyaW5nO1xuICBkYXRhPzogYW55O1xuICBlcnJvcj86IEVycm9yO1xuICB1c2VySWQ/OiBzdHJpbmc7XG4gIHNlc3Npb25JZD86IHN0cmluZztcbiAgcmVxdWVzdElkPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgTG9nZ2VyIHtcbiAgcHJpdmF0ZSBzdGF0aWMgaW5zdGFuY2U6IExvZ2dlcjtcbiAgcHJpdmF0ZSBsb2dMZXZlbDogTG9nTGV2ZWw7XG4gIHByaXZhdGUgY29udGV4dDogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKGNvbnRleHQ6IHN0cmluZyA9ICdBcHBsaWNhdGlvbicpIHtcbiAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMubG9nTGV2ZWwgPSB0aGlzLmdldExvZ0xldmVsKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoY29udGV4dDogc3RyaW5nID0gJ0FwcGxpY2F0aW9uJyk6IExvZ2dlciB7XG4gICAgaWYgKCFMb2dnZXIuaW5zdGFuY2UpIHtcbiAgICAgIExvZ2dlci5pbnN0YW5jZSA9IG5ldyBMb2dnZXIoY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBMb2dnZXIuaW5zdGFuY2U7XG4gIH1cblxuICBwcml2YXRlIGdldExvZ0xldmVsKCk6IExvZ0xldmVsIHtcbiAgICBjb25zdCBlbnZMZXZlbCA9IHByb2Nlc3MuZW52LkxPR19MRVZFTD8udG9Mb3dlckNhc2UoKSBhcyBMb2dMZXZlbDtcbiAgICBjb25zdCB2YWxpZExldmVsczogTG9nTGV2ZWxbXSA9IFsnZGVidWcnLCAnaW5mbycsICd3YXJuJywgJ2Vycm9yJ107XG5cbiAgICBpZiAodmFsaWRMZXZlbHMuaW5jbHVkZXMoZW52TGV2ZWwpKSB7XG4gICAgICByZXR1cm4gZW52TGV2ZWw7XG4gICAgfVxuXG4gICAgLy8gRGVmYXVsdCB0byBpbmZvIGluIHByb2R1Y3Rpb24sIGRlYnVnIGluIGRldmVsb3BtZW50XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicgPyAnaW5mbycgOiAnZGVidWcnO1xuICB9XG5cbiAgcHJpdmF0ZSBzaG91bGRMb2cobGV2ZWw6IExvZ0xldmVsKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbGV2ZWxzOiBMb2dMZXZlbFtdID0gWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InXTtcbiAgICBjb25zdCBjdXJyZW50TGV2ZWxJbmRleCA9IGxldmVscy5pbmRleE9mKHRoaXMubG9nTGV2ZWwpO1xuICAgIGNvbnN0IG1lc3NhZ2VMZXZlbEluZGV4ID0gbGV2ZWxzLmluZGV4T2YobGV2ZWwpO1xuXG4gICAgcmV0dXJuIG1lc3NhZ2VMZXZlbEluZGV4ID49IGN1cnJlbnRMZXZlbEluZGV4O1xuICB9XG5cbiAgcHJpdmF0ZSBmb3JtYXRNZXNzYWdlKFxuICAgIGxldmVsOiBMb2dMZXZlbCxcbiAgICBtZXNzYWdlOiBzdHJpbmcsXG4gICAgZGF0YT86IGFueSxcbiAgICBlcnJvcj86IEVycm9yXG4gICk6IExvZ0RhdGEge1xuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbGV2ZWwsXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dCxcbiAgICAgIGRhdGEsXG4gICAgICBlcnJvcixcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBsb2dUb0NvbnNvbGUobG9nRGF0YTogTG9nRGF0YSkge1xuICAgIGNvbnN0IHsgbGV2ZWwsIG1lc3NhZ2UsIHRpbWVzdGFtcCwgY29udGV4dCwgZGF0YSwgZXJyb3IgfSA9IGxvZ0RhdGE7XG4gICAgY29uc3QgbG9nTWVzc2FnZSA9IGBbJHt0aW1lc3RhbXB9XSBbJHtsZXZlbC50b1VwcGVyQ2FzZSgpfV0gWyR7Y29udGV4dH1dICR7bWVzc2FnZX1gO1xuXG4gICAgc3dpdGNoIChsZXZlbCkge1xuICAgICAgY2FzZSAnZGVidWcnOlxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICBjb25zb2xlLmRlYnVnKGxvZ01lc3NhZ2UsIGRhdGEgfHwgJycpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBjb25zb2xlLmVycm9yKGxvZ01lc3NhZ2UsIGVycm9yIHx8IGRhdGEgfHwgJycpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBkZWJ1ZyhtZXNzYWdlOiBzdHJpbmcsIGRhdGE/OiBhbnkpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coJ2RlYnVnJykpIHtcbiAgICAgIGNvbnN0IGxvZ0RhdGEgPSB0aGlzLmZvcm1hdE1lc3NhZ2UoJ2RlYnVnJywgbWVzc2FnZSwgZGF0YSk7XG4gICAgICB0aGlzLmxvZ1RvQ29uc29sZShsb2dEYXRhKTtcbiAgICB9XG4gIH1cblxuICBpbmZvKG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIGlmICh0aGlzLnNob3VsZExvZygnaW5mbycpKSB7XG4gICAgICBjb25zdCBsb2dEYXRhID0gdGhpcy5mb3JtYXRNZXNzYWdlKCdpbmZvJywgbWVzc2FnZSwgZGF0YSk7XG4gICAgICB0aGlzLmxvZ1RvQ29uc29sZShsb2dEYXRhKTtcbiAgICB9XG4gIH1cblxuICB3YXJuKG1lc3NhZ2U6IHN0cmluZywgZGF0YT86IGFueSkge1xuICAgIGlmICh0aGlzLnNob3VsZExvZygnd2FybicpKSB7XG4gICAgICBjb25zdCBsb2dEYXRhID0gdGhpcy5mb3JtYXRNZXNzYWdlKCd3YXJuJywgbWVzc2FnZSwgZGF0YSk7XG4gICAgICB0aGlzLmxvZ1RvQ29uc29sZShsb2dEYXRhKTtcbiAgICB9XG4gIH1cblxuICBlcnJvcihtZXNzYWdlOiBzdHJpbmcsIGVycm9yPzogRXJyb3IgfCBhbnksIGRhdGE/OiBhbnkpIHtcbiAgICBpZiAodGhpcy5zaG91bGRMb2coJ2Vycm9yJykpIHtcbiAgICAgIGNvbnN0IGxvZ0RhdGEgPSB0aGlzLmZvcm1hdE1lc3NhZ2UoXG4gICAgICAgICdlcnJvcicsXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IHVuZGVmaW5lZFxuICAgICAgKTtcbiAgICAgIHRoaXMubG9nVG9Db25zb2xlKGxvZ0RhdGEpO1xuXG4gICAgICAvLyBJbiBwcm9kdWN0aW9uLCB5b3UgbWlnaHQgd2FudCB0byBzZW5kIGVycm9ycyB0byBleHRlcm5hbCBzZXJ2aWNlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB0aGlzLnNlbmRUb0V4dGVybmFsU2VydmljZShsb2dEYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHNlbmRUb0V4dGVybmFsU2VydmljZShsb2dEYXRhOiBMb2dEYXRhKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFNlbnRyeSBpbnRlZ3JhdGlvblxuICAgICAgaWYgKHByb2Nlc3MuZW52LlNFTlRSWV9EU04gJiYgbG9nRGF0YS5sZXZlbCA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aGlzLnNlbmRUb1NlbnRyeShsb2dEYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gQ2xvdWRXYXRjaCBMb2dzIGludGVncmF0aW9uXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuQVdTX0NMT1VEV0FUQ0hfTE9HX0dST1VQKSB7XG4gICAgICAgIHRoaXMuc2VuZFRvQ2xvdWRXYXRjaChsb2dEYXRhKTtcbiAgICAgIH1cblxuICAgICAgLy8gR2VuZXJpYyB3ZWJob29rIGludGVncmF0aW9uXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuRVJST1JfV0VCSE9PS19VUkwgJiYgbG9nRGF0YS5sZXZlbCA9PT0gJ2Vycm9yJykge1xuICAgICAgICB0aGlzLnNlbmRUb1dlYmhvb2sobG9nRGF0YSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXh0ZXJuYWxFcnJvcikge1xuICAgICAgLy8gRG9uJ3QgbGV0IGV4dGVybmFsIHNlcnZpY2UgZXJyb3JzIGJyZWFrIHRoZSBhcHBsaWNhdGlvblxuICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHNlbmQgbG9nIHRvIGV4dGVybmFsIHNlcnZpY2U6JywgZXh0ZXJuYWxFcnJvcik7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZW5kVG9TZW50cnkobG9nRGF0YTogTG9nRGF0YSkge1xuICAgIC8vIER5bmFtaWMgaW1wb3J0IHRvIGF2b2lkIGJ1bmRsZSBibG9hdCBpZiBTZW50cnkgaXNuJ3QgdXNlZFxuICAgIHRyeSB7XG4gICAgICAvLyBDaGVjayBpZiBTZW50cnkgaXMgYXZhaWxhYmxlIGJlZm9yZSBpbXBvcnRpbmdcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAod2luZG93IGFzIGFueSkuU2VudHJ5KSB7XG4gICAgICAgIC8vIENsaWVudC1zaWRlIFNlbnRyeSBpcyBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgU2VudHJ5ID0gKHdpbmRvdyBhcyBhbnkpLlNlbnRyeTtcbiAgICAgICAgdGhpcy5zZW5kVG9TZW50cnlJbnN0YW5jZShTZW50cnksIGxvZ0RhdGEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVHJ5IGR5bmFtaWMgaW1wb3J0IGZvciBzZXJ2ZXItc2lkZVxuICAgICAgICBpbXBvcnQoJ0BzZW50cnkvbmV4dGpzJylcbiAgICAgICAgICAudGhlbigoU2VudHJ5KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbmRUb1NlbnRyeUluc3RhbmNlKFNlbnRyeS5kZWZhdWx0IHx8IFNlbnRyeSwgbG9nRGF0YSk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgICAgLy8gU2VudHJ5IG5vdCBhdmFpbGFibGUsIHNpbGVudGx5IGlnbm9yZVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gY2F0Y2gge1xuICAgICAgLy8gU2VudHJ5IG5vdCBhdmFpbGFibGUsIHNpbGVudGx5IGlnbm9yZVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgc2VuZFRvU2VudHJ5SW5zdGFuY2UoU2VudHJ5OiBhbnksIGxvZ0RhdGE6IExvZ0RhdGEpIHtcbiAgICBpZiAobG9nRGF0YS5lcnJvcikge1xuICAgICAgU2VudHJ5LmNhcHR1cmVFeGNlcHRpb24obG9nRGF0YS5lcnJvciwge1xuICAgICAgICB0YWdzOiB7XG4gICAgICAgICAgY29udGV4dDogbG9nRGF0YS5jb250ZXh0LFxuICAgICAgICAgIGxldmVsOiBsb2dEYXRhLmxldmVsLFxuICAgICAgICB9LFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgIG1lc3NhZ2U6IGxvZ0RhdGEubWVzc2FnZSxcbiAgICAgICAgICBkYXRhOiBsb2dEYXRhLmRhdGEsXG4gICAgICAgICAgdXNlcklkOiBsb2dEYXRhLnVzZXJJZCxcbiAgICAgICAgICBzZXNzaW9uSWQ6IGxvZ0RhdGEuc2Vzc2lvbklkLFxuICAgICAgICAgIHJlcXVlc3RJZDogbG9nRGF0YS5yZXF1ZXN0SWQsXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgU2VudHJ5LmNhcHR1cmVNZXNzYWdlKGxvZ0RhdGEubWVzc2FnZSwge1xuICAgICAgICBsZXZlbDogbG9nRGF0YS5sZXZlbCA9PT0gJ2Vycm9yJyA/ICdlcnJvcicgOiAnd2FybmluZycsXG4gICAgICAgIHRhZ3M6IHtcbiAgICAgICAgICBjb250ZXh0OiBsb2dEYXRhLmNvbnRleHQsXG4gICAgICAgIH0sXG4gICAgICAgIGV4dHJhOiB7XG4gICAgICAgICAgZGF0YTogbG9nRGF0YS5kYXRhLFxuICAgICAgICAgIHVzZXJJZDogbG9nRGF0YS51c2VySWQsXG4gICAgICAgICAgc2Vzc2lvbklkOiBsb2dEYXRhLnNlc3Npb25JZCxcbiAgICAgICAgICByZXF1ZXN0SWQ6IGxvZ0RhdGEucmVxdWVzdElkLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBzZW5kVG9DbG91ZFdhdGNoKGxvZ0RhdGE6IExvZ0RhdGEpIHtcbiAgICAvLyBBV1MgQ2xvdWRXYXRjaCBpbnRlZ3JhdGlvbiB3b3VsZCBnbyBoZXJlXG4gICAgLy8gVGhpcyBpcyBhIHBsYWNlaG9sZGVyIGZvciBhY3R1YWwgaW1wbGVtZW50YXRpb25cbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIE9ubHkgcnVuIG9uIHNlcnZlciBzaWRlXG4gICAgICBjb25zb2xlLmxvZygnQ2xvdWRXYXRjaCBsb2dnaW5nIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlbmRUb1dlYmhvb2sobG9nRGF0YTogTG9nRGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmZXRjaChwcm9jZXNzLmVudi5FUlJPUl9XRUJIT09LX1VSTCEsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4ubG9nRGF0YSxcbiAgICAgICAgICBzZXJ2aWNlOiAnbWFuaXRvcy1waW50YWRhcycsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5PREVfRU5WLFxuICAgICAgICB9KSxcbiAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gc2VuZCBlcnJvciB0byB3ZWJob29rOicsIGVycm9yKTtcbiAgICB9XG4gIH1cblxuICAvLyBFbmhhbmNlZCBlcnJvciB0cmFja2luZyBtZXRob2RzXG4gIGxvZ0FwaUVycm9yKGVuZHBvaW50OiBzdHJpbmcsIGVycm9yOiBFcnJvciwgY29udGV4dD86IGFueSwgdXNlcklkPzogc3RyaW5nLCBzZXNzaW9uSWQ/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmVycm9yKGBBUEkgRXJyb3I6ICR7ZW5kcG9pbnR9YCwgZXJyb3IsIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB1c2VySWQsXG4gICAgICBzZXNzaW9uSWQsXG4gICAgICBlbmRwb2ludCxcbiAgICAgIHVzZXJBZ2VudDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IHVuZGVmaW5lZCxcbiAgICAgIHVybDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IHVuZGVmaW5lZCxcbiAgICB9KTtcbiAgfVxuXG4gIGxvZ0RhdGFiYXNlRXJyb3Iob3BlcmF0aW9uOiBzdHJpbmcsIGVycm9yOiBFcnJvciwgY29udGV4dD86IGFueSkge1xuICAgIHRoaXMuZXJyb3IoYERhdGFiYXNlIEVycm9yOiAke29wZXJhdGlvbn1gLCBlcnJvciwge1xuICAgICAgY29udGV4dCxcbiAgICAgIG9wZXJhdGlvbixcbiAgICAgIGRhdGFiYXNlOiBwcm9jZXNzLmVudi5EQVRBQkFTRV9VUkwgPyAnY29uZmlndXJlZCcgOiAnbm90LWNvbmZpZ3VyZWQnLFxuICAgIH0pO1xuICB9XG5cbiAgbG9nU2VjdXJpdHlFdmVudChldmVudDogc3RyaW5nLCB1c2VySWQ/OiBzdHJpbmcsIGRldGFpbHM/OiBhbnksIHNldmVyaXR5OiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnIHwgJ2NyaXRpY2FsJyA9ICdtZWRpdW0nKSB7XG4gICAgY29uc3QgbGV2ZWwgPSBzZXZlcml0eSA9PT0gJ2NyaXRpY2FsJyA/ICdlcnJvcicgOiAnd2Fybic7XG4gICAgY29uc3QgbG9nRGF0YSA9IHRoaXMuZm9ybWF0TWVzc2FnZShsZXZlbCwgYFNlY3VyaXR5IEV2ZW50OiAke2V2ZW50fWAsIHtcbiAgICAgIHVzZXJJZCxcbiAgICAgIGRldGFpbHMsXG4gICAgICBzZXZlcml0eSxcbiAgICAgIGlwOiBkZXRhaWxzPy5pcCxcbiAgICAgIHVzZXJBZ2VudDogZGV0YWlscz8udXNlckFnZW50LFxuICAgIH0pO1xuXG4gICAgaWYgKGxldmVsID09PSAnZXJyb3InKSB7XG4gICAgICB0aGlzLmVycm9yKGBTZWN1cml0eSBFdmVudDogJHtldmVudH1gLCB1bmRlZmluZWQsIHsgdXNlcklkLCBkZXRhaWxzLCBzZXZlcml0eSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53YXJuKGBTZWN1cml0eSBFdmVudDogJHtldmVudH1gLCB7IHVzZXJJZCwgZGV0YWlscywgc2V2ZXJpdHkgfSk7XG4gICAgfVxuICB9XG5cbiAgbG9nVXNlckFjdGlvbihhY3Rpb246IHN0cmluZywgdXNlcklkOiBzdHJpbmcsIGRldGFpbHM/OiBhbnkpIHtcbiAgICB0aGlzLmluZm8oYFVzZXIgQWN0aW9uOiAke2FjdGlvbn1gLCB7XG4gICAgICB1c2VySWQsXG4gICAgICBkZXRhaWxzLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSk7XG4gIH1cblxuICBsb2dQZXJmb3JtYW5jZU1ldHJpYyhtZXRyaWM6IHN0cmluZywgdmFsdWU6IG51bWJlciwgY29udGV4dD86IGFueSkge1xuICAgIHRoaXMuaW5mbyhgUGVyZm9ybWFuY2U6ICR7bWV0cmljfWAsIHtcbiAgICAgIHZhbHVlLFxuICAgICAgY29udGV4dCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRXJyb3IgYm91bmRhcnkgc3BlY2lmaWMgbG9nZ2luZ1xuICBsb2dFcnJvckJvdW5kYXJ5KGVycm9yOiBFcnJvciwgZXJyb3JJbmZvOiBhbnksIGNvbXBvbmVudE5hbWU/OiBzdHJpbmcpIHtcbiAgICB0aGlzLmVycm9yKCdFcnJvciBCb3VuZGFyeSBDYXVnaHQgRXJyb3InLCBlcnJvciwge1xuICAgICAgY29tcG9uZW50TmFtZSxcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uY29tcG9uZW50U3RhY2ssXG4gICAgICBlcnJvckJvdW5kYXJ5OiB0cnVlLFxuICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXG4gICAgfSk7XG4gIH1cblxuICAvLyBDbGllbnQtc2lkZSBlcnJvciB0cmFja2luZ1xuICBsb2dDbGllbnRFcnJvcihlcnJvcjogRXJyb3IsIGNvbnRleHQ/OiBhbnkpIHtcbiAgICB0aGlzLmVycm9yKCdDbGllbnQgRXJyb3InLCBlcnJvciwge1xuICAgICAgY29udGV4dCxcbiAgICAgIHVzZXJBZ2VudDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCA6IHVuZGVmaW5lZCxcbiAgICAgIHVybDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cubG9jYXRpb24uaHJlZiA6IHVuZGVmaW5lZCxcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgY2xpZW50U2lkZTogdHJ1ZSxcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBDb252ZW5pZW5jZSBleHBvcnRzXG5leHBvcnQgY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCdBcHBsaWNhdGlvbicpO1xuXG4vLyBDb250ZXh0LXNwZWNpZmljIGxvZ2dlcnNcbmV4cG9ydCBjb25zdCBhdXRoTG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCdBdXRoJyk7XG5leHBvcnQgY29uc3QgYXBpTG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCdBUEknKTtcbmV4cG9ydCBjb25zdCBkYkxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgnRGF0YWJhc2UnKTtcbmV4cG9ydCBjb25zdCBzZWN1cml0eUxvZ2dlciA9IExvZ2dlci5nZXRJbnN0YW5jZSgnU2VjdXJpdHknKTtcblxuLy8gRXhwb3J0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG5leHBvcnQgZGVmYXVsdCBsb2dnZXI7XG4iXSwibmFtZXMiOlsiTG9nZ2VyIiwiZ2V0SW5zdGFuY2UiLCJjb250ZXh0IiwiaW5zdGFuY2UiLCJnZXRMb2dMZXZlbCIsInByb2Nlc3MiLCJlbnZMZXZlbCIsImVudiIsIkxPR19MRVZFTCIsInRvTG93ZXJDYXNlIiwidmFsaWRMZXZlbHMiLCJpbmNsdWRlcyIsInNob3VsZExvZyIsImxldmVsIiwibGV2ZWxzIiwiY3VycmVudExldmVsSW5kZXgiLCJpbmRleE9mIiwibG9nTGV2ZWwiLCJtZXNzYWdlTGV2ZWxJbmRleCIsImZvcm1hdE1lc3NhZ2UiLCJtZXNzYWdlIiwiZGF0YSIsImVycm9yIiwidGltZXN0YW1wIiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwibG9nVG9Db25zb2xlIiwibG9nRGF0YSIsImxvZ01lc3NhZ2UiLCJ0b1VwcGVyQ2FzZSIsImNvbnNvbGUiLCJkZWJ1ZyIsImluZm8iLCJ3YXJuIiwiRXJyb3IiLCJ1bmRlZmluZWQiLCJzZW5kVG9FeHRlcm5hbFNlcnZpY2UiLCJTRU5UUllfRFNOIiwic2VuZFRvU2VudHJ5IiwiQVdTX0NMT1VEV0FUQ0hfTE9HX0dST1VQIiwic2VuZFRvQ2xvdWRXYXRjaCIsIkVSUk9SX1dFQkhPT0tfVVJMIiwic2VuZFRvV2ViaG9vayIsImV4dGVybmFsRXJyb3IiLCJ3aW5kb3ciLCJTZW50cnkiLCJzZW5kVG9TZW50cnlJbnN0YW5jZSIsInRoZW4iLCJkZWZhdWx0IiwiY2F0Y2giLCJjYXB0dXJlRXhjZXB0aW9uIiwidGFncyIsImV4dHJhIiwidXNlcklkIiwic2Vzc2lvbklkIiwicmVxdWVzdElkIiwiY2FwdHVyZU1lc3NhZ2UiLCJsb2ciLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNlcnZpY2UiLCJlbnZpcm9ubWVudCIsImxvZ0FwaUVycm9yIiwiZW5kcG9pbnQiLCJ1c2VyQWdlbnQiLCJuYXZpZ2F0b3IiLCJ1cmwiLCJsb2NhdGlvbiIsImhyZWYiLCJsb2dEYXRhYmFzZUVycm9yIiwib3BlcmF0aW9uIiwiZGF0YWJhc2UiLCJEQVRBQkFTRV9VUkwiLCJsb2dTZWN1cml0eUV2ZW50IiwiZXZlbnQiLCJkZXRhaWxzIiwic2V2ZXJpdHkiLCJpcCIsImxvZ1VzZXJBY3Rpb24iLCJhY3Rpb24iLCJsb2dQZXJmb3JtYW5jZU1ldHJpYyIsIm1ldHJpYyIsInZhbHVlIiwibG9nRXJyb3JCb3VuZGFyeSIsImVycm9ySW5mbyIsImNvbXBvbmVudE5hbWUiLCJjb21wb25lbnRTdGFjayIsImVycm9yQm91bmRhcnkiLCJsb2dDbGllbnRFcnJvciIsImNsaWVudFNpZGUiLCJsb2dnZXIiLCJhdXRoTG9nZ2VyIiwiYXBpTG9nZ2VyIiwiZGJMb2dnZXIiLCJzZWN1cml0eUxvZ2dlciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/logger.ts\n"));

/***/ })

}]);